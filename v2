#property indicator_chart_window
#property indicator_buffers 3
#property indicator_plots 3

#property indicator_label1 "BUY Signal"
#property indicator_type1 DRAW_ARROW
#property indicator_color1 clrLimeGreen
#property indicator_width1 3

#property indicator_label2 "SELL Signal"
#property indicator_type2 DRAW_ARROW
#property indicator_color2 clrRed
#property indicator_width2 3

#property indicator_label3 "Test Signal"
#property indicator_type3 DRAW_ARROW
#property indicator_color3 clrYellow
#property indicator_width3 2

#property strict

// U≈æivatelsk√© vstupy
input int adxPeriod = 7;
input int rsiPeriod = 14;
input int bbPeriod = 20;
input double bbDeviation = 2.0;

// Parametry pro sign√°ly
input int adxMinLevel = 25;        // Minim√°ln√≠ ADX √∫rove≈à (zv√Ω≈°eno pro silnƒõj≈°√≠ trendy)
input int rsiBuyMin = 40;          // Minim√°ln√≠ RSI pro BUY
input int rsiBuyMax = 70;          // Maxim√°ln√≠ RSI pro BUY
input int rsiSellMin = 30;         // Minim√°ln√≠ RSI pro SELL
input int rsiSellMax = 60;         // Maxim√°ln√≠ RSI pro SELL
input bool showTestSignals = false; // Zobrazit testovac√≠ sign√°ly

// Handle indik√°tor≈Ø
int adxHandle, rsiHandle, bbHandle;

// Buffery pro sign√°ly
double buyBuffer[];
double sellBuffer[];
double testBuffer[];

// Buffery pro hodnoty
double adxMain[], plusDI[], minusDI[];
double rsiBuffer[], bbMiddle[];

// Glob√°ln√≠ promƒõnn√© pro sledov√°n√≠ zmƒõn
datetime lastUpdateTime = 0;
int lastRatesTotal = 0;

// Funkce pro kontrolu validn√≠ch dat
bool IsValidValue(double value)
{
   return value != 0.0 && value != EMPTY_VALUE && value > -999999 && value < 999999;
}

// Inicializace indik√°tor≈Ø
int OnInit()
{
   // Nastaven√≠ buffer≈Ø
   SetIndexBuffer(0, buyBuffer, INDICATOR_DATA);
   SetIndexBuffer(1, sellBuffer, INDICATOR_DATA);
   SetIndexBuffer(2, testBuffer, INDICATOR_DATA);
   
   // Nastaven√≠ ≈°ipek
   PlotIndexSetInteger(0, PLOT_ARROW, 233); // ≈°ipka nahoru pro BUY
   PlotIndexSetInteger(1, PLOT_ARROW, 234); // ≈°ipka dol≈Ø pro SELL
   PlotIndexSetInteger(2, PLOT_ARROW, 108); // k≈ô√≠≈æek pro TEST
   
   // Nastaven√≠ offsetu
   PlotIndexSetDouble(0, PLOT_EMPTY_VALUE, 0.0);
   PlotIndexSetDouble(1, PLOT_EMPTY_VALUE, 0.0);
   PlotIndexSetDouble(2, PLOT_EMPTY_VALUE, 0.0);

   adxHandle = iADX(_Symbol, _Period, adxPeriod);
   rsiHandle = iRSI(_Symbol, _Period, rsiPeriod, PRICE_CLOSE);
   bbHandle = iBands(_Symbol, _Period, bbPeriod, bbDeviation, 0, PRICE_CLOSE);

   if (adxHandle == INVALID_HANDLE || rsiHandle == INVALID_HANDLE || bbHandle == INVALID_HANDLE)
   {
      Print("‚ùå Chyba p≈ôi vytv√°≈ôen√≠ indik√°torov√Ωch handle.");
      return INIT_FAILED;
   }

   Print("‚úÖ ADX RSI Signal Indik√°tor √∫spƒõ≈°nƒõ inicializov√°n");
   Print("üìä Parametry: ADX>", adxMinLevel, " RSI BUY:", rsiBuyMin, "-", rsiBuyMax, " RSI SELL:", rsiSellMin, "-", rsiSellMax);
   return INIT_SUCCEEDED;
}

// Vyƒçi≈°tƒõn√≠ handle
void OnDeinit(const int reason)
{
   IndicatorRelease(adxHandle);
   IndicatorRelease(rsiHandle);
   IndicatorRelease(bbHandle);
   Print("üßπ Indik√°tor vyƒçi≈°tƒõn");
}

// V√Ωpoƒçet
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime &time[],
                const double &open[],
                const double &high[],
                const double &low[],
                const double &close[],
                const long &tick_volume[],
                const long &volume[],
                const int &spread[])
{
   if (rates_total < 5) return 0;

   // Kontrola, zda se objevily nov√° data
   bool hasNewData = (rates_total > lastRatesTotal) || (time[0] != lastUpdateTime);
   
   if (!hasNewData && prev_calculated > 0)
   {
      return rates_total; // ≈Ω√°dn√° nov√° data, nepoƒç√≠t√°me znovu
   }

   // Aktualizace glob√°ln√≠ch promƒõnn√Ωch
   lastRatesTotal = rates_total;
   lastUpdateTime = time[0];

   int copied = rates_total;

   // Kop√≠rov√°n√≠ dat z indik√°tor≈Ø
   if (CopyBuffer(adxHandle, 0, 0, copied, adxMain) <= 0) 
   {
      Print("‚ùå Chyba p≈ôi kop√≠rov√°n√≠ ADX dat");
      return 0;
   }
   if (CopyBuffer(adxHandle, 1, 0, copied, plusDI) <= 0) 
   {
      Print("‚ùå Chyba p≈ôi kop√≠rov√°n√≠ +DI dat");
      return 0;
   }
   if (CopyBuffer(adxHandle, 2, 0, copied, minusDI) <= 0) 
   {
      Print("‚ùå Chyba p≈ôi kop√≠rov√°n√≠ -DI dat");
      return 0;
   }
   if (CopyBuffer(rsiHandle, 0, 0, copied, rsiBuffer) <= 0) 
   {
      Print("‚ùå Chyba p≈ôi kop√≠rov√°n√≠ RSI dat");
      return 0;
   }
   if (CopyBuffer(bbHandle, 1, 0, copied, bbMiddle) <= 0) 
   {
      Print("‚ùå Chyba p≈ôi kop√≠rov√°n√≠ BB dat");
      return 0;
   }

   // Debug v√Ωpisy ka≈æd√Ωch 20 tick≈Ø (ƒçastƒõji pro lep≈°√≠ sledov√°n√≠)
   if (rates_total % 20 == 0)
   {
      Print("=== DEBUG INFO ===");
      Print("Rates total: ", rates_total, " Prev calculated: ", prev_calculated);
      Print("ADX: ", adxMain[1], " +DI: ", plusDI[1], " -DI: ", minusDI[1]);
      Print("RSI: ", rsiBuffer[1], " BB: ", bbMiddle[1], " Close: ", close[1]);
      Print("Time: ", TimeToString(time[0]));
   }

   // Zpracov√°n√≠ v≈°ech sv√≠ƒçek (vƒçetnƒõ nejnovƒõj≈°√≠)
   int startIndex = (prev_calculated > 0) ? prev_calculated - 1 : 1;
   
   for(int i = startIndex; i < rates_total && i < copied; i++)
   {
      // Kontrola validn√≠ch dat
      if (!IsValidValue(adxMain[i]) || !IsValidValue(plusDI[i]) || !IsValidValue(minusDI[i]) ||
          !IsValidValue(rsiBuffer[i]) || !IsValidValue(bbMiddle[i]) || !IsValidValue(close[i]))
      {
         buyBuffer[i] = 0.0;
         sellBuffer[i] = 0.0;
         testBuffer[i] = 0.0;
         continue;
      }

      // Testovac√≠ sign√°l - ka≈æd√Ωch 100 sv√≠ƒçek (pouze pokud je povoleno)
      if (showTestSignals && i % 100 == 0)
      {
         testBuffer[i] = low[i] - 20 * _Point;
         Print("üß™ Test sign√°l na pozici ", i);
      }
      else
      {
         testBuffer[i] = 0.0;
      }

      // Optimalizovan√© podm√≠nky pro BUY sign√°l
      bool isBuy = (
         adxMain[i] > adxMinLevel &&                    // ADX nad minim√°ln√≠ √∫rovn√≠
         plusDI[i] > minusDI[i] &&                      // +DI > -DI (bullish momentum)
         plusDI[i] > 20 &&                              // +DI mus√≠ b√Ωt nad 20
         rsiBuffer[i] > rsiBuyMin && rsiBuffer[i] < rsiBuyMax &&  // RSI v optim√°ln√≠m rozsahu
         close[i] > bbMiddle[i] &&                      // Cena nad st≈ôedn√≠ Bollinger Band
         close[i] > open[i]                             // Sv√≠ƒçka je zelen√° (bullish)
      );

      // Optimalizovan√© podm√≠nky pro SELL sign√°l
      bool isSell = (
         adxMain[i] > adxMinLevel &&                    // ADX nad minim√°ln√≠ √∫rovn√≠
         minusDI[i] > plusDI[i] &&                      // -DI > +DI (bearish momentum)
         minusDI[i] > 20 &&                             // -DI mus√≠ b√Ωt nad 20
         rsiBuffer[i] > rsiSellMin && rsiBuffer[i] < rsiSellMax &&  // RSI v optim√°ln√≠m rozsahu
         close[i] < bbMiddle[i] &&                      // Cena pod st≈ôedn√≠ Bollinger Band
         close[i] < open[i]                             // Sv√≠ƒçka je ƒçerven√° (bearish)
      );

      // Priorita: BUY m√° p≈ôednost p≈ôed SELL
      if (isBuy)
      {
         buyBuffer[i] = low[i] - 15 * _Point;
         sellBuffer[i] = 0.0;
         Print("üü¢ BUY SIGNAL na pozici ", i, " ƒças: ", TimeToString(time[i]), " ADX:", adxMain[i], " RSI:", rsiBuffer[i], " +DI:", plusDI[i]);
      }
      else if (isSell)
      {
         sellBuffer[i] = high[i] + 15 * _Point;
         buyBuffer[i] = 0.0;
         Print("üî¥ SELL SIGNAL na pozici ", i, " ƒças: ", TimeToString(time[i]), " ADX:", adxMain[i], " RSI:", rsiBuffer[i], " -DI:", minusDI[i]);
      }
      else
      {
         buyBuffer[i] = 0.0;
         sellBuffer[i] = 0.0;
      }
   }

   return rates_total;
}
